Agile Revision Session
======================

Back of the book for notes.


Past Paper Questions
--------------------

> "Do you expect a given answer for some questions."

There are points raised by the author of the material. The examiner is expecting to see some points of this, but you should be looking to expand upon this.

Alternative answers are both likely and acceptable.

Anything intelligent is good :), more than facts are expected. Analysis and comparison are the issues are good to see on the bigger questions: **discuss**.

Agile is a popular approach, but there are different ways of being agile. Bring together your own experience from IY and the fuck the group project. Combine that with the raw ideals of agile.

Good paragraph structure is helpful.


Problems with the exam
----------------------

> "I'm worried about not being able to learn a list of topics."

Pair programming -> TDD -> Refractoring.

Follow the thread through.

Definitely no anti-pattern question :). However you might get anti-patterns in a resit.

Having major surgery is not a good exam strategy ;).

Some of the stronger answers draw in other aspects of agile.

FDD vs. XP: compare and contrast. FDD has some upfront design and planning. XP does not. FDD has a single person related, etc. Advantages and disadvantages.

1 mark a minutes, resolve this appropriately. More structure for more marks. Some marks will be easier to gain than others.


Model Driven Development
------------------------

Model is the central artifact. Emphasis on developing a model of the system to be built. Models are described in various ways.

Computational dependant. Business logic of the model

Platform independent. Business logic without worries of platform.

Can take platform independent model and build platform dependant models.

All the time you focus on the model.

In the context of agile:

* If you focus on the model, you focus on design by default, violating XP.
* Is it actually possible for this to be agile?
* Creating all XX UML models for the platform dependant ones, straight away violating no upfront design.
* Why does XP have no upfront design? Designs go out of date quickly.
* What happens when code and design get out of sync?
* What if the models are executable? Modelling language and tools to make code. Can then start having agile models.
* Depends on what tools you have? Agile principals?
* Compilers are tools too though.
* How do you test this?
    * In experience, testing is tied up in simulations.
    * Lots of research goes into this.

Read essays linked of the blackboard page.



