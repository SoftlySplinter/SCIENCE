# SEM2220 - Mobile Solutions

Mobile devices (phones, tablets and other handheld devices) are the fastest growing area of computing. Typical applications involve a wide range of software and system issues. This module will investigate those issues, giving students experience and understanding of the best ways of building different types of mobile applications.


## Introduction

*Scope of mobile systems, , mobile web, native apps, design choices, main platforms, overview of implications (2 lectures)*

### Staff

- **[Chris Loftus](mailto:cwl@aber.ac.uk) (E38)**
- [Neil Taylor](mailto:nst@aber.ac.uk) (C58)
- [Andrew Star](mailto:aos@aber.ac.uk) (C47)

### Learning Outcomes

1. Demonstrate an advanced understanding of the domain of mobile systems.
  * Quite a broad overview of these systems.
  * High level view.
  * Give a flavour of specific systems (iOS, Android).
2. Analyse and evaluate mobile solutions in a range of application areas and be able to critically evaluate their effectiveness.
  * Have to be critical at M level.
  * Research. Pros and cons.
3. Evaluate the social, legal, ethical and professional issues involved in implementing mobile applications.
  * Neil will be talking about this in the context of mobile.
4. Implement representative mobile systems.
  * Playing with the technologies.
  * Building an android, iOS and mobile web app.

### Assessment

- Mobile Web-based Programming project **20%** *22/10/2013 to 04/11/2013*
- iOS-based Programming project **20%** *12/11/2013 to 25/11/2013*
- Android-based Programming project **20%** *02/12/2013 to 16/12/2013*
- Case study analysis **40%** *10/12/2013 to 22/01/2014*

### Motivation

In 2012 the whole mobiles ecosystem's revenue was $1,551 billion; equivalent to 2.2% of global GDP. 

5% CAGR (Compound Annual Growth Rate).

These are only projected figures, the picture is much bigger than this as this only includes money which takes into account the money which stays within the ecosystem (doesn't include ecommerce, etc.). The affect is much higher.

### Mobile Landscape

Constantly changing given that its a new market. The iPhone was the real kickstarter for this in 2007.

[Timeline](https://gsmaintelligence.com/timeline/) of the history mobile telephones.

Difference between "smart" and "feature" phones.

Mobile subscribers are growing 4 times faster than the global population. Reducing now (especially in the West) due to market saturation.

More scope for growth in developing countries.

Asia Pacific accounts for approximately half of global subscribers.

Total sim-enabled connections (including machine to machine (M2M) connections). Estimated 7.6% CAGR 2012-2017. Percentage of M2M connections is increasing rapidly.

Multiple devices (tables/phones/etc.) allow growth in sim-enabled connections.

Mobile data traffic is increasing rapidly. Video speculated to be one of the most rapidly increasing traffic.

### Mobile versus Desktop

Over time the sales of desktops (PCs & Laptops) is decreasing while the sale of mobile devices is increasing.

### Some predictions by GSMA

* Asia predicted to add approx. 50% of all connections/subscribers between 2013-17
* Same period Latin America and Africa next 20%
* Subscriber growth in developed nations slowing (e.g. 1% in UK)
* Total data traffic load in 2012 was 0.9 Exabyte/month).
* Predicted to be 11.2 EB/mth.


### Chief Stakeholders

* Network operators
* Content providers
* OS vendors
* Device vendors

### Fragmentation and Differentiation

Issue of fragmentation and differentiation, related to:
* the number of OS variants, 
* the number of device vendors wishing to customise the OS, 
* different browsers,
* Network operators and device vendors do not like commoditisation.
  * Don't want to be treated like commodities which are values on price.

Top 25 ranked apps in 2012 take 15% of all revenue. Only 2% of App Store newcomers get into the top 250 apps.

Free apps are becoming more of a norm, especially with the saturation of android.

### Mobile Network Operators

Revenues are decreasing due to over-the-top services (i.e. using online services over SMS or phone calls).

Operators will push, via their shop sales-assistant commission, those devices they gain the biggest discounts on.

High profile phones promoted, often Android.

Apple disrupts this model due to a locked mindshare.

Psychological hook of "cheap" contract phones. Free now, pay later ideology.

Billing relationship with the customer. Paying for things using your mobile account rather than via a bank account (directly). Small transaction fee for this service to generate revenue.

* 48% of the world's population do not have a bank account.

Something for the future, not quite so prevalent at the moment.

### Rich Communication Service

Threat of over the top (OTT) services such as Skype. Quality of service is currently an issue here, but voice call is growing very slowly (13% in 2008 to 4% 2012).

GSMA responded by developing a Rich Communication Service specification. Only aimed at long term evolution (LTE) networks (4G). Aims to provide this as a universal service. 17 different implementations by MNOs including AT&T, Telefonica, Verizon and Verdafon.

### Device Vendors (OEMs)

Nokia sales falling. Haven't kept up with the trends.

Samsung now the major player. Mainly due to their adoption of Android.

Apple improving with mobiles.

RIM/Blackberry are focusing on development.

Building an Android smartphone involves:

* Choosing an OS.
* OEMs design phone (HW, UX, required changes to the Android OS UX) plus apps to include.
* Marketing.
* Negotiations with MNOs to arrange bulk discounts.
* Production test units sent to MNOs, app developers and Google.
* Phone is shipped to MNOs and independent stores
* MNOs customise with their own apps.
* Sales to public plus marketing.

Can also go down the stock phone route.

Inception to market is approximately around 6 months when based on an existing OS.

Apple is a little easier to to the locked-in syndrome.

### Types of Phone

* Basic Phones
  * Call and SMS support only.
* Feature Phones
  * No touch screen
  * Browser becoming standardised.
* Smart Phones
  * Definition changes year-on-year.
  * Expectations change a lot.
  * More sensors and technology.
* Phablets
  * Large smartphones.
* Tablets
  * Same functionality as smartphones, often without SIM.
* Slates
  * Large tablets.
* Non-phone devices
  * iPod touch
  * eBook readers
  * Google Glass
  * Watches like the Apple Pebble.
  * Rely on bluetooth or similar.

### Operating System Vendors

Android leading market player.

iOS popular.

Symbian (dead now) and Blackberry not doing well.

Windows Phone a late starter.

### Android Fragmentation

There are 24 listed Android device manufacturers but at least 259 different device models currently on sale.

Lots of different screen sizes, resolutions, hardware capability, etc.

There is only one manufacturer for Apple products.

Version 4.1+ *Jelly Bean* most prevalent, but versions 4.0, 3.0 and 2.3 are still a large market share.

Security problems, most malware attacks on Android.

iOS is mostly all the same version. However, companies often prescribe a 2-3 purchase cycle. Corporate world might need to take into account older versions.

Google allow fragmentation to make Android more interesting to OEMs, However this can get in the way of updates.

Webkit configuration varies; browser fragmentation.

Tried to stop fragmentation in version 3, but this lead to new forks. So this has been re-introduced in version 4.

### Fragmentation and Differentiation

Differentiation gives a unique selling point (USP) for vendors. Sticking with the same model.

Fragmentation leads to security issues and makes the OS more complex to handle screen sizes, etc. More testing needed. Therefore increased cost.

### Windows Phone 8

Microsoft and Nokia. A closed environment (or "walled garden").

No fragmentation/differentiation. Very few OEMs interested.

### How to join the OS game?

Buy into it.

Web as OS platform. Firefox OS is trying hard with cheap alternatives. HTML5, JS, CSS3 and APIs to access hardware.

Very fragmented, depending on rendering engine.

### Mobile Webkits are not always the same

Can be configured differently. Must be careful with mobile websites.

Depends on location too (UC Browser more popular than Android in Asia).

### Proxy versus full browsers.

Opera mini, for example.

* HTTP request (encrypted)
* Proxy Server
  * Target HTTP Server resources
  * Renders page
  * Compresses into an image map
* Image map returned to Opera mini (encrypted).

Cheaper and faster over a slow network. Very popular in certain developing countries with low bandwidth.

Cheap in terms in processing too.

JS is handled by the proxy server. Not always perfect and may not be enabled.

### Content Providers

App Stores

* Apple App Store is a walled garden. 70% developer revenue.
* Google Play. 70% developer revenue.
* Amazon Android Appstore.
* Others (apk) security issues with this.

## Mobile Web

*Basic tools, responsive web, matching platform expectations, testing, delivery. (5 lectures plus practicals)*

### Objectives

* To be able to build some simple mobile web sites/applications and view them via desktop browsers, mobile browsers and as mobile applications (hybrid apps).
* To gain an insight into design issues especially multiple screen sizes and browser support.
* To use a common mobile web framework to help build a mobile web application.
* To user PhoneGapâ„¢ to turn a webb application into a "native" application which can be deployed.
* To use some common testing technologies for mobile web.

### Overview

* Is mobile web being exploited?
* Three main approaches:
  1. Web site
  2. Hybrid App
  3. Native App
* Challenges for mobile web developers
* Standards are a moving target.
* How can we be informed what support there is?
* Given a complex situation, how can we make testing tractable?

#### Core philosophy 
Progressive enhancement and not graceful degradation.

### Web site/app Approach

#### Pros
* One codebase
* Cross platform
* Familiar technology
* Easy to distribute to both mobile and non-mobile

#### Cons
* Lack app store distributions
* Weak access to device services
* Performance (JS interpretation).
* Not as slick as a native app

### Hybrid Applications

Native wrapper around HTML and CSS and JS.

#### Pros
* One codebase
* Cross platform
* Better accesses to device services
* Can distribute via app stores
* Familiar technologies

#### Cons
* No full access to device services
* Performance
* Not as slick as native apps

### Native Applications

#### Pros
* Highly polished
* Good performance (potentially)
* Good developer support platform
* App store distribution.

#### Cons
* Platform specific
* Multiple codebases

### Progressive Enhancement not Graceful Degradation

Graceful degradation (of a website):

* Focus is on building a great experience for the latest browsers, testing one browser version back.
* Old browsers provide poor, but passable, experience, only show-stopped bugs fixed.

Progressive enhancement (of website):

* Focus on content, not browsers.

### Responsive Web Design (RWD)

* Fluid grids
* Media queries - use `em` over `px`.



### Mobile virtual viewports

Mobiles have a virtual viewport which bypass the media queries.

Use the viewport meta-tag to ask the viewport width to be the same as the actual width.

### Breakpoints

Research suggest lines of text should be between 45-75 characters for comfortable reading. Columns help with this.

### Mobile-first progressive enhancement.

Design site for the mobile device. If media queries are supported and on a bigger screen, add to the existing CSS for mobile to add for the styling rules and changing font sizes.

Simplification of complex designs is harder than making a simple design more complex.

### Server-side Detection of Device Capabilities

Client side RWD alone may not be sufficient.

There are some server-side approaches:

* User-agent sniffing.
* Client-side reconnaissance missions.

Classes of "device".

**RESS** (Responsibe Web Design and Server-side Components).

### The problem

Some services will only run on a mobile device (Phone calls, accelerometer).

Some services are more significant on a mobile device (location awareness, etc.), be careful not to run into the *Hide and Cry* anti-pattern.

Some classes of device are very different (feature versus smart phone).

What we spit out is so different that RWD alone won'y help. Need variants of the website.

Image sizing issues that RWD won't solve.

### User-agent sniffing

Can use HTTP User-Agent request header with a device description repository to work out:

* Device hardware characteristics
* Operating System
* Browser characteristics

### Example: Detecting viewport width

```javascript
var width = (winder.innerWidth > 0) ? Window.innderWidth : screen.width;
document.cookie = "sitewidth="width;
document.location.reload();
```

```php
if(isset($_COOKIE["sitewidth"]) {
  $_SESSION["screenwidth"] = $_COOKIE["sitewidth"];
}
// ...
if($_SESSION["screenwidth"] <= "380") {
  include("includes/mobile-nav.inc.php");
} else {
  include("includes/desktop-nav.inc.php");
}
```

### Herding Devices into Device Classes

**Device Class**: An abstract collection of common characteristics of similar devices and their browsers.

Why? Because we don't want our server-side code to have to deal with every device (this isn't scalable).

### Typical Classes

* Higher Mobile (WebKit-based, >= 320px width)
* Simpler Mobile (minimal JS support, >176px width)
* Tablets
* Desktop
* Unsupported (if no SLL, Cookies, JS, or < 176px width)

Does unsupported break progressive enhancement?

### What to send?

* Stylesheets and Code based on class
* Sometimes single codebase is too small (watch out for duplication of common code).
* RESS can help with codebase maintenance.

### Responsive Web Design and Server Side Components

Combine client-side RWD with templating in the codebase for different classes of device.

### Sometimes HTML5, CSS3 and JS isn't enough

Many HTML5 features aren't widely supported.

Can't publish to application stores.

Perhaps go for a hybridge: part native, part HTML.

PhoneGap/Cordova is the best known hybrid technology.

## IOS Native Apps

*Objective-C, relevant design patterns, platform design considerations, handling data, using sensors and location (5 lectures plus practicals)*

### Objective-C

Based on C and Object-Orientation (based on Smalltalk), has basic rules of C but most of the syntax is smalltalk-based.

Some repeated information is involved, but this is improving.

Uses late binding (names are looked up at runtime, not compile time).

Good, but unusual, object syntax with some useful extensions and libraries.

Verbose (*A: yay boilerplate*), designed to be descriptive (*A: **yay** dot-enter programming*).

Likely to change with each release (good and bad).

#### Basic Syntax and Objects



##### Logging and Strings

```objc
NSLog(@"Message");

NSString *var = @"Some message";
NSLog(@"Message: %@.", var);
```


##### Booleans

```objc
BOOL true = YES;
BOOL false = NO;
```


##### Numbers

```objc
NSNumber *num = @10;

// Conversion to unsigned int
NSUInteger uInt = [num unsignedIntegerValue];
```

#### Arrays

```objc
NSArray *arr = @[...];

// Accessing elements
arr[index];

// Something about NSArrays being immutable objects.
```


#### Dictionaries

```objc
NSDictionary *dict = @{@"key": @"value"};

// Accessing
NSString *val = dict[@"key"];
```

#### Objects and Messages

Messages are Objective-C's version of methods, where the Java syntax would be:

```java
ObjectName.methodName()
```

The Objective-C syntax is:

```objc
[objectName messageName]
```

Example:

```objc
NSArray *temp = @[@"Test", @"2"];

NSLog(@"%@", [temp description]);
// Logs information about temp
```

##### Storing the output of Messages

Just need to worry about typing

```objc
NSArray *temp = @[@"Test", @"2"];
NSString *result = [temp description]
NSLog(result);
```

#### Parameters

Messages can have parameters, however they may act differently than expected.

```objc
[object methodName:parameter namedParameter:value]
```


##### Initialisation

```objc
[[Class alloc] init];
```

#### Conditionals and Loops

```
if(condition) {
    // ...
} else if(condition) {
    // ...
} else {
    // ...
}
```

```
switch(thing) {
    case value:
        // ...
        break;
}
```

```
for(Class *item in iterable) {
    // ...
}
```

#### Blocks

Blocks are like basic methods.

```objc
void (^block)(void) = ^{
    // ...
};
```

Inkoving a block:

```objc
block();
```

#### Classes

In a header file (.h):

```objc
@interface Name : NSObject
@property Type *name;
@property NSString *myName;
@end
```

Implementing the interface (.m):

```objc
#import Name.h

@implementation Name
@end
```

Accessing properties

```objc
Name *name = [[Name alloc] init];
name.myName = @"Value";
```

##### Method Signatures

In many languages, you might see:

``` java
void m(int x, int y, String text)
```

A similar method in Obj-C is:

``` objc
- (void) mAtX: (NSInteger) x
         atY: (NSInteger) y
         withText: (NSString *) text
```

Calling this:

``` objc
[obj mAtX: 2 atY: 32 withText @"a message"]
```

The method name is: `mAtX:atY:withText`

##### Properties

Defined with the `@property` syntax.

The attributes in the `()` control how the property manages the underlying data value.

The `IBOutlet` is only used on properties that are linked to the user interface.

`atomic` is used for multi-threading purposes (read locks, etc.).

Under the bonnet, this is an instance variable (ivar).

Good practise is to cover your ears and pretend they're just properties.

##### Instances

``` objc
Example *inst;
inst = [[Example alloc] init];
// or
inst = [Example new];
```

`alloc` and `init` is the typical Obj-C way as classes often have different initialisation techniques. `alloc` is a class method, `init` is an instance method.

#### Protocols

Similar to Java interfaces. There are some features where you can have required and optional methods.

Optional methods act as empty methods if they are not implemented.

Set in the header file (.h)

#### Primitive Types

Primitive types from C can be used in Obj-C, e.g. int, long, float, double.

Additional types:

1. `BOOL` (`YES` or `NO`)
2. `NSInteger` (typedef to either long or int depending on architecture)
3. `CGFloat` (typedef to either float or double depending on architecture)

#### Memory Management

Memory management is achieved by checking the number of references to an object.

In older code, you needed to write lines of code to state when you wanted to keep an object in memory.

Modern applications use ARC (Automatic Reference Counting).

The compile tracks when objects should be kept in memory or removed from the application.

### Application Structure

Typical project implementations have a simple structure which corresponds to MVC

`AppDelegate` accesses the model (if there is one).

The storyboard is the view, describe many screens in a single file.

`ControllerView` is the controller.

### Developing an Application

1. Make a new view-based progect,
2. Add extra views in the Storyboard,
3. Design the application by placing buttons, etc. *allows easy prototyping*
4. Make new `ViewController` files and link them to the views
5. Via drag and drop, define Actions and Outlets in the `ViewController` and link outlets and actions to interface (associate views to controllers)
6. Implement model separately (if complex enough).

### Rule of Thumb

If your newly created app crashes when trying to load a new screen, then you usually have:

1. Messed up linking the view to the view controller.
2. Done something wrong when linking an outlet or action to a screen.

The error message should give you a clue as to what is wrong.

### Types of Interfaces

* Tabbed screens
* Tables
* Linked Views
* More examples from iOSDevUK

You can put each of the views into the storyboard and define how you segue from screen to screen then write code to pass data between them.

#### Tabbed Screens

#### Tables

`UITableView` is used to display repeating section of data. `UITableViewCell` is a cell in the table.

Unlike classic tables on other platforms, there is only a single column.

Tables contains many sections, which in turn contains many rows.

The entire table can have a header and footer. Sections can also have a header and footer.

Each table must have at least one section to be complete.

##### Table Styles

Table style is set at build time only.

###### Plain

Cells flush to each other

###### Grouped

Not in iOS7.

##### Cells

Each row contains a cell.

When a row's data is to be displayed, the `UITableView` will request the cell.

By default, the `UITableViewCell` is used to degine a cell.

The cell is initialised in the method: `tableView:cellForRowAtndexPath:`

A table can contain different types of cells for different rows.

The cell is reused.

###### Cell Structure

* Content
  * Layout depends on Style
    * `UITableViewCellStyleDefault`
    * `UITableViewCellStyleSubtitle`
    * `UITableViewCellStyle1` (right detail)
    * `UITableViewCellStyle2` (left detail)
* Accessory
  * Disclosure Indicator
  * Detail Disclosure Button
  * Check Mark

###### Custom Cells

Content of a cell can be defined in code, but is tedious.

It is more likely that IB will be used to define the layout for the cell and use a View Controller to control the behaviour.

#### Table View Contoller

`UITableViewContoller` is a subclass of `UIViewControler` that is designed to manage `UITableView`s.

If a new view based controller is created, the XIB will contain the table linked to this controller.

In order to provide custom behaviour, the following methods needed to be implemented:

* `UITableViewDelegate`
  * Manage selections, 
  * Configure section headings and footers, 
  * Help to delete and reorder cells, 
  * Perform other actions
  * (All optional)
* `UITableViewDataSource`
  * The data source provides the table-view object with the information it needs to construct and modify a table view. Two are required.

#### Linked Views

### Data Storage on iOS

Techniques for storing and retrieving data on the iPhone.

XML and SQLite provide the best portability.

#### NSUserDefaults

User preferences.

Persistent map.

#### Property List Serialisation

Mechanism to store a selected number of data types in a property list (plist).

#### NSCoder

Technique to save more complex objects.

#### XML

XML data files.

#### SQLite

Small memory footprint SQL database.

#### Core Data

More complex system, but offering a powerful way to manage data and relationships. Best integration with iCloud.

### Application Sandbox

iOS applications are run in a protected area on the device. Within this area there is a defined structure of Directories that you can access.

The developer is responsible for managing files that are created within the application area.


### SQLite 3

Database and library available in iOS.

C library, which needs to be included in the project.

Create a SQLite database on the command line and include in the project.

Need to marshal data into and out of the database, with some conversions (e.g. Strings).

#### Where to store the database

By default, your database is in the default bundle, inside your application.

If read-only data is needed, it can remain there.

Write access needs to be moved to the Documents directory.

## Android Native Apps

*Relevant design patterns, platform design considerations, handling data, using sensors and location, handling device variation (5 lectures plus practicals)*

## Bringing it all together

*Legal, social, ethical and professional issues. Selecting platforms and delivery methods, getting the interface right. (3 lectures)*

